#!/usr/bin/env bash

# Init:

# Enable bash options
shopt -s globstar
shopt -s nullglob

# set -euo pipefail

# SSG Options
template_pre_content=
template_post_content=
output_dir="out"
export PYTHONUTF8=1

# Helpers:

is_in_ricing_guide=0
if [ "${PWD##*/}" = "ricing-guide" ]; then
	printf "Running in ricing-guide\n"
	is_in_ricing_guide=1
fi

fin() {
	[ -n "${report_individual_builds:-}" ] && printf '\e[32m\e[1mBuilt\e[0m %s\n' "$1"
}

clean_markup() {
	local -n ptr=${1}
	ptr=${ptr//'<span class="reset">'/}
	ptr=${ptr//'</span>'/}
	ptr=${ptr#*'<h1'*'>'}
	ptr=${ptr%'</h1>'*}
	ptr=${ptr//'}'/}
	ptr=${ptr//'{'/}
	ptr=${ptr//'<img'*'>'/}
}

slugify() {
	echo "$1" | iconv -c -t ascii//TRANSLIT | sed -E 's/[~^]+//g' | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr A-Z a-z
}

base_url="https://nes.is-a.dev/${output_dir}/"
format_doc_heading() {
	doc_path=${1#'./src/'}
	doc_path=${doc_path%'.'*}

	[[ "$markup" =~ \<h1\>(.*)\<\/h1\> ]] # uses variable from parent here
	doc_title=${BASH_REMATCH[1]}
	clean_markup doc_title

	doc_url=$1
	doc_url=${doc_url/"./${output_dir}/"/"$base_url"}

	doc_heading=${template_pre_content/'!DOCUMENT-PATH!'/"$doc_path"}
	doc_heading=${doc_heading//'!TITLE!'/"$doc_title"}
	doc_heading=${doc_heading//'!URL!'/"${doc_url}"}

	toc="<ul>"
	while read -r heading; do
		local level=${heading%% *}
		local without_heading=${heading#$level }
		local slug=$(slugify "${without_heading}")
		case "$heading" in
		'## '*)
			toc+="<li><a href='#${slug}'>${without_heading}</a></li>"
			;;
		'### '*)
			toc+="<li class='toc-subheading'><a href='#${slug}'>${without_heading}</a></li>"
			;;
		esac
	done < <(grep -P "##+" $2)
	toc+='</ul>'
	doc_heading=${doc_heading/'!TABLEOFCONTENT!'/"$toc"}
}

# Tasks:
build_md() {
	out=${1/src/"$output_dir"}
	out=${out/.md/.html}
	markup=""
	if [ "$is_in_ricing_guide" -eq 1 ]; then
		markup="$(python3 ./.tooling/gfm.py "$1")"
	else
		markup=$(quiet=true bash ./.tooling/pond.sh "$1")
	fi
	format_doc_heading "$out" "$1"
	mkdir -p "$(dirname "$out")"
	printf '%s\n%s\n%s' "$doc_heading" "$markup" "$template_post_content" >"$out"
	fin "$1"
}

build_html() {
	out=${1/src/"$output_dir"}
	cp "$1" "$out"
	fin "$1"
}

#=======================
# Generic Build Function
#=======================

build() {
	file=$1
	case "${file##*.}" in
	'org')
		build_org "$file"
		;;
	'html')
		build_html "$file" &
		;;
	'md')
		build_md "$file" &
		;;
	*)
		return
		;;
	esac
}

generate_org_full() {
	emacs "${emacs_arguments[@]}" >/dev/null 2>&1
}

count=0
generate_index() {
	cp ./src/index.html ./$output_dir/index.html 2>/dev/null
	find "$output_dir"/ \
		-maxdepth 1 \
		-type d \
		-not -path "$output_dir/" \
		-printf '%T@ %p\n' | sort -n | cut -d' ' -f2 | while read -r folder; do
		local posts=""
		while read -r match; do
			file=${match%%:*}
			title=${match#*:}

			# clean the <h1> markup
			clean_markup title

			# extract post_description from HTML comment
			desc=$(grep -Po '<!--\s*post_description=\K.*(?=-->)' "$file" | head -n1)
			image=$(grep -Po '<!--\s*post_image=\K.*(?=-->)' "$file" | head -n1)

			[ -z "${title/ /}" ] && continue

			posts+="<li>"
			if [ -n "$image" ]; then
				posts+="<img class='img-pxl' src='${image//'"'/}' alt='Post Image' />"
			fi
			posts+="<div><a class='special' href='/$file'>$title</a>"
			[ -n "$desc" ] && posts+="<p class='description'>${desc//'"'/}</p>"
			posts+="</div></li>\n"

			((count++))
		done < <(grep -ProH '<h1.*?>.*</h1>' "${folder}")
		folder=${folder#*/}
		sed -i "s\`!POSTS-${folder^^}!\`$posts\`g" "./$output_dir/index.html"
	done

	printf "\r\e[33m\e[1mBUILT\e[0m %d files.\n" "$count"
	cp ./$output_dir/index.html ./index.html
}


generate_rss() {
	local rss_file="./rss.xml"
	local site_url="http://nes.is-a.dev"
	local site_title="Nes's Personal Site"
	local site_description="My little corner of the internet"
	local pub_date=$(date -R)

	{
		echo '<?xml version="1.0" encoding="UTF-8" ?>'
		echo '<rss version="2.0">'
		echo '    <channel>'
		echo "        <title>$site_title</title>"
		echo "        <link>$site_url</link>"
		echo "        <description>$site_description</description>"
		echo "        <language>en-us</language>"
		echo "        <pubDate>$pub_date</pubDate>"
		echo "        <lastBuildDate>$pub_date</lastBuildDate>"
	} >$rss_file

	find $output_dir/ \
		-maxdepth 1 \
		-type d \
		-not -path "$output_dir/" \
		-printf '%T@ %p\n' | sort -nr | cut -d' ' -f2 | while read -r folder; do
		while read -r match; do
			file=${match%%:*}
			title=${match#*:}

			clean_markup title

			[ -z "${title/ /}" ] && continue

			item_link="$site_url/${file#$output_dir/}"
			item_pub_date=$(date -R -r "$file")

			{
				echo '        <item>'
				echo "            <title>$title</title>"
				echo "            <link>$item_link</link>"
				echo "            <description>$title</description>"
				echo "            <pubDate>$item_pub_date</pubDate>"
				echo "            <guid>$item_link</guid>"
				echo '        </item>'
			} >>$rss_file
		done < <(grep -ProH '<h1.*?>.*</h1>' "${folder}")
	done

	{
		echo '    </channel>'
		echo '</rss>'
	} >>$rss_file
}

# generate_index

if command -v bunx >/dev/null 2>&1; then
	node_runner="bunx"
else
	node_runner="npx"
fi

perform_html_optimization () {
	OUT_DIR="out"

# Loop through all .html files in OUT_DIR
find "$OUT_DIR" -type f -name "*.html" | while read -r file; do
    # echo "Minifying: $file"

    tmpfile=$(mktemp)
    ${node_runner} html-minifier-terser \
        --collapse-whitespace \
        --remove-comments \
        --remove-optional-tags \
        --remove-redundant-attributes \
        --remove-script-type-attributes \
        --remove-style-link-type-attributes \
        --use-short-doctype \
        --minify-css true \
        --minify-js true \
        "$file" -o "$tmpfile" 2>/dev/null && mv "$tmpfile" "$file"  # || printf "Failed to minify: $file\n"
done
}

perform_css_optimization () {
	# This function is not used in the current context, but can be used to optimize CSS files
	# echo "Performing CSS optimization..."
	${node_runner} postcss ./assets/styles/styles.css --output ./assets/styles.css
}

liveStartMessage="\n\033[43m\033[30m LIVE BUILD \e[0m"



case "${1:-}" in
"dbg")
	quiet=true pond_debug=true bash ./.tooling/pond.sh "$2" # 1>/dev/null
	exit
	;;
"build-css")
	perform_css_optimization
	exit
	;;
"minify-out")
	perform_html_optimization
	exit
	;;
"rm")
	rm -r ./$output_dir/${2}.html
	rm -r ./$output_dir/${2}.md
	generate_index
	exit
	;;
"winfix")
	find ./src -type f -not -path '*/.*'  -print0 | xargs -0 -n 1 -P 4 dos2unix
	exit
	;;
"serve")
	python3 -m http.server 5050
	exit
	;;
"live")
	./.tooling/hs.py --ui
	exit
	;;
esac

# generate_index

# Default: Build All Files

intermediate=
IFS="
"
while read -r line; do
	if [[ "$line" == *"!CONTENT!" ]]; then
		template_pre_content=$intermediate
		intermediate=
		continue
	fi
	intermediate+=$line$IFS
done <./template.html
template_post_content=$intermediate


mkdir -p $output_dir
rm -r -f $output_dir/.pond-tmp
files_to_build="$*"
if [ -z "${files_to_build/ /}" ]; then
	files_to_build=$(echo ./src/**/*.html ./src/*.html ./src/*.md ./src/**/*.md ./src/**/*.org ./src/*.org)
fi
oifs=$IFS
IFS=" "
for file in ${files_to_build}; do
	build "$file"
	count=$((count + 1))
done
IFS=$oifs

for job in $(jobs -p); do
	wait "$job"
done

# POST BUILD TASKS

generate_index
generate_rss
perform_css_optimization
# perform_html_optimization


exit
