<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/png" href="/favicon.png" />
		<meta name="author" content="nes" />
		<title>Memory for Idiots (like me)</title>
		<link rel="stylesheet" href="/assets/styles.css" />
	</head>
	<body>
	  <article>

<header>
<h1>Memory for Idiots (like me)</h1>
</header>
Just a collection of my notes from my time using C<br/>
<br/>
<h2 id="analogy">Analogy</h2>
<p>
<img src="/assets/images/memory-analogy.svg" alt="" title="" loading="lazy" /><br/>
Essentially the CPU cache is like a tub of water you have at home (program), But since it's at home, its very fast to access it.<br/>
The stack is like a outdoor water tank, still very fast to access but slower than the cache and you can access a lot more water at once too.<br/>
The heap is like a village well, It takes time to get to it but once you're there, you can effectivley get as much water as you want.<br/>
<br/>
</p>
<h3 id="example-problem: returning a string from a function">Example Problem: Returning a string from a function</h3>
<p>
Let's say we want to write a function in C to return a string time stamp, Very simple right?<br/>
<br/>
</p>
<h4 id="initial-attempt:">Initial Attempt:</h4>
<p>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">char</span> <span style="color:#dcdccc">&ast;</span><span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">() {</span>
    <span style="color:#dfdfbf; font-weight:bold">char</span> timestamp<span style="color:#dcdccc">[</span><span style="color:#dca3a3; font-weight:bold">100</span><span style="color:#dcdccc">];</span>
    <span style="color:#aabfe3">snprintf</span><span style="color:#dcdccc">(</span>timestamp<span style="color:#dcdccc">,</span> <span style="color:#e3ceab">sizeof</span><span style="color:#dcdccc">(</span>timestamp<span style="color:#dcdccc">),</span> <span style="color:#cc9393">&quot;%llu&quot;</span><span style="color:#dcdccc">,</span> <span style="color:#aabfe3">time</span><span style="color:#dcdccc">(</span>NULL<span style="color:#dcdccc">));</span>
    <span style="color:#e3ceab">return</span> timestamp<span style="color:#dcdccc">;</span>
<span style="color:#dcdccc">}</span>
	</code>
</pre>
But this won't work, The compiler even gives us a warning<br/>
<pre>
	<code>e.c:6:12: warning: function returns address of local variable &lsqb;-Wreturn-local-addr&rsqb;
    6 |     return timestamp;
      |            ^<strike>~</strike>~~~
</code>
</pre>
Okay but why doesn't this work? It's because our <code>timestamp</code> variable doesnt exist anymore once timestamp returns, So the pointer we return is pointing to garbage.<br/>
There's three ways we can fix it, By marking our memory static, By taking a char buffer as a argument or by <i>allocating</i> our memory so that it won't disapper once our function is complete.<br/>
<br/>
</p>
<h4 id="solution-1: static">Solution 1: static</h4>
<p>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">char</span> <span style="color:#dcdccc">&ast;</span><span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">() {</span>
    <span style="color:#dfdfbf; font-weight:bold">static char</span> timestamp<span style="color:#dcdccc">[</span><span style="color:#dca3a3; font-weight:bold">100</span><span style="color:#dcdccc">];</span>
    <span style="color:#aabfe3">snprintf</span><span style="color:#dcdccc">(</span>timestamp<span style="color:#dcdccc">,</span> <span style="color:#e3ceab">sizeof</span><span style="color:#dcdccc">(</span>timestamp<span style="color:#dcdccc">),</span> <span style="color:#cc9393">&quot;%llu&quot;</span><span style="color:#dcdccc">);</span>
    <span style="color:#e3ceab">return</span> timestamp<span style="color:#dcdccc">;</span>
<span style="color:#dcdccc">}</span>
	</code>
</pre>
This works, because now <code>timestamp</code> is static so it will exist for the lifetime of the program, But the problem is if the function is called again, timestamp gets overwritten!<br/>
Example:<br/>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span>a <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">();</span>
<span style="color:#aabfe3">printf</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;%s</span><span style="color:#dca3a3; font-weight:bold">\n</span><span style="color:#cc9393">&quot;</span><span style="color:#dcdccc">,</span>a<span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">sleep</span><span style="color:#dcdccc">(</span><span style="color:#dca3a3; font-weight:bold">5</span><span style="color:#dcdccc">);</span>
<span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span>b <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">();</span>
<span style="color:#aabfe3">printf</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;%s, %s</span><span style="color:#dca3a3; font-weight:bold">\n</span><span style="color:#cc9393">&quot;</span><span style="color:#dcdccc">,</span>a<span style="color:#dcdccc">,</span>b<span style="color:#dcdccc">);</span>
	</code>
</pre>
gives<br/>
<pre>
	<code>1682173737
1682173742, 1682173742
</code>
</pre>
so the memory <code>a</code> is pointing to changes when <code>getTimestamp()</code> is called again.<br/>
<br/>
<b>NOTE</b>: static memory is only initialized once<br/>
<br/>
</p>
<h3 id="solution-2: taking a pointer">Solution 2: taking a pointer</h3>
<p>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">char</span> <span style="color:#dcdccc">&ast;</span><span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">(</span><span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span> buf<span style="color:#dcdccc">,</span> <span style="color:#dfdfbf; font-weight:bold">size_t</span> bufSize<span style="color:#dcdccc">) {</span>
    <span style="color:#aabfe3">snprintf</span><span style="color:#dcdccc">(</span>buf<span style="color:#dcdccc">,</span> bufSize<span style="color:#dcdccc">,</span> <span style="color:#cc9393">&quot;%llu&quot;</span><span style="color:#dcdccc">,</span> <span style="color:#aabfe3">time</span><span style="color:#dcdccc">(</span>NULL<span style="color:#dcdccc">));</span>
    <span style="color:#e3ceab">return</span> buf<span style="color:#dcdccc">;</span>
<span style="color:#dcdccc">}</span>
	</code>
</pre>
In this version, we ignore memory entirely, We simply take in a pointer to some memory (stack or heap, doesn't matter) and write to it.<br/>
But if we didn't take in a size for the buffer there's a chance we could overflow the buffer. So there is added risk with this, but it allows for better memory reusability, since the caller can call it with the same memory.<br/>
<br/>
</p>
<h3 id="solution-3: allocating on the heap">Solution 3: allocating on the heap</h3>
<p>
<pre>
	<code><span style="color:#7f9f7f; font-style:italic">// Caller must free() the given memory</span>
<span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span> <span style="color:#aabfe3">getTimestamp</span><span style="color:#dcdccc">() {</span>
    <span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span> timestamp <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">malloc</span><span style="color:#dcdccc">(</span><span style="color:#dca3a3; font-weight:bold">100</span><span style="color:#dcdccc">);</span>
    <span style="color:#aabfe3">snprintf</span><span style="color:#dcdccc">(</span>buf<span style="color:#dcdccc">,</span> <span style="color:#dca3a3; font-weight:bold">100</span><span style="color:#dcdccc">,</span> <span style="color:#cc9393">&quot;%llu&quot;</span><span style="color:#dcdccc">,</span> <span style="color:#aabfe3">time</span><span style="color:#dcdccc">(</span>NULL<span style="color:#dcdccc">));</span>
    <span style="color:#e3ceab">return</span> timestamp<span style="color:#dcdccc">;</span>   
<span style="color:#dcdccc">}</span>
	</code>
</pre>
In this case, each time our function is called, we allocate a tiny buffer and write to it, This isn't the best solution for this particular problem since allocating such a small chunk wastes time, But if we are dealing with bigger chunks, It's a good solution<br/>
<br/>
</p>
<h3 id="conclusion">Conclusion</h3>
<p>
Solution 1 has the chance of corruption so it's kind of impractical but if you know you won't need the previous result again then it is fine.<br/>
Solution 2 & 3 both offload some work on the callee, namely allocating / freeing memory.<br/>
<br/>
Solution 2 might also need a sanity check for bufSize being sufficient and the pointer not being NULL.<br/>
Solution 3 could cause a memory leak if the caller forgets to free the memory.<br/>
<br/>
So it's important to pick the correct solution for the problem at hand, in this case, Solution 2 or 3 would be good.<br/>
<br/>
</p>
<h2 id="getting-memory">Getting Memory</h2>
<p>
Note: In case of encountering an error like insufficient memory, these functions will return NULL and set <code>errno</code>, See the manpage.<br/>
<div class="row">
<div>
</p>
<h4 id="malloc">malloc</h4>
<p>
Get unitialized memory 
</div>
<div>
</p>
<h4 id="calloc">calloc</h4>
<p>
Get zero initialized memory 
</div>
<div>
</p>
<h4 id="aligned_alloc">aligned_alloc</h4>
<p>
Get uninitialized memory aligned on a given boundry
</div>
</div>
<a href="https://man.openbsd.org/malloc">manpage</a><br/>
<br/>
</p>
<h3 id="mmap">mmap</h3>
<p>
This is a linux syscall for mapping pages of memory but it can be useful for certain things like,<br/>
Loading a entire file into memory:<br/>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">int</span> fd <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">open</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;passwd&quot;</span><span style="color:#dcdccc">,</span> O_RDONLY<span style="color:#dcdccc">);</span>
<span style="color:#dfdfbf; font-weight:bold">struct</span> stat s<span style="color:#dcdccc">;</span>
<span style="color:#aabfe3">fstat</span><span style="color:#dcdccc">(</span>fd<span style="color:#dcdccc">, &amp;</span>s<span style="color:#dcdccc">);</span>
<span style="color:#dfdfbf; font-weight:bold">char</span> <span style="color:#dcdccc">&ast;</span>buffer <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">mmap</span><span style="color:#dcdccc">(</span><span style="color:#dca3a3; font-weight:bold">0</span><span style="color:#dcdccc">,</span> s<span style="color:#dcdccc">.</span>st_size<span style="color:#dcdccc">,</span> PROT_READ <span style="color:#dcdccc">|</span> PROT_WRITE<span style="color:#dcdccc">,</span> MAP_PRIVATE<span style="color:#dcdccc">,</span> fd<span style="color:#dcdccc">,</span> <span style="color:#dca3a3; font-weight:bold">0</span><span style="color:#dcdccc">);</span>
buffer<span style="color:#dcdccc">[</span>s<span style="color:#dcdccc">.</span>st_size<span style="color:#dcdccc">-</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">] =</span> <span style="color:#cc9393">&apos;\0&apos;</span><span style="color:#dcdccc">;</span>
<span style="color:#aabfe3">printf</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;%s&quot;</span><span style="color:#dcdccc">,</span>buffer<span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">munmap</span><span style="color:#dcdccc">(</span>buffer<span style="color:#dcdccc">,</span> s<span style="color:#dcdccc">.</span>st_size<span style="color:#dcdccc">);</span>
	</code>
</pre>
<br/>
Writing to a file:<br/>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">char</span> <span style="color:#dcdccc">&ast;</span>str <span style="color:#dcdccc">=</span> <span style="color:#cc9393">&quot;Hello World&quot;</span><span style="color:#dcdccc">;</span>
<span style="color:#dfdfbf; font-weight:bold">int</span> fd <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">open</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;test&quot;</span><span style="color:#dcdccc">,</span> O_RDWR <span style="color:#dcdccc">|</span> O_CREAT<span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">ftruncate</span><span style="color:#dcdccc">(</span>fd<span style="color:#dcdccc">,</span> <span style="color:#aabfe3">strlen</span><span style="color:#dcdccc">(</span>str<span style="color:#dcdccc">)+</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">);</span>
<span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span> buffer <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">mmap</span><span style="color:#dcdccc">(</span><span style="color:#dca3a3; font-weight:bold">0</span><span style="color:#dcdccc">,</span> <span style="color:#aabfe3">strlen</span><span style="color:#dcdccc">(</span>str<span style="color:#dcdccc">)+</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">,</span> PROT_READ <span style="color:#dcdccc">|</span> PROT_WRITE<span style="color:#dcdccc">,</span> MAP_SHARED<span style="color:#dcdccc">,</span> fd<span style="color:#dcdccc">,</span> <span style="color:#dca3a3; font-weight:bold">0</span><span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">memcpy</span><span style="color:#dcdccc">(</span>buffer<span style="color:#dcdccc">,</span> str<span style="color:#dcdccc">,</span> <span style="color:#aabfe3">strlen</span><span style="color:#dcdccc">(</span>str<span style="color:#dcdccc">)+</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">msync</span><span style="color:#dcdccc">(</span>buffer<span style="color:#dcdccc">,</span> <span style="color:#aabfe3">strlen</span><span style="color:#dcdccc">(</span>str<span style="color:#dcdccc">)+</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">,</span> MS_SYNC<span style="color:#dcdccc">);</span>
<span style="color:#aabfe3">munmap</span><span style="color:#dcdccc">(</span>buffer<span style="color:#dcdccc">,</span> <span style="color:#aabfe3">strlen</span><span style="color:#dcdccc">(</span>str<span style="color:#dcdccc">)+</span><span style="color:#dca3a3; font-weight:bold">1</span><span style="color:#dcdccc">);</span>
	</code>
</pre>
Full example: <a href="https://kuafu1994.github.io/MoreOnMemory/shared-memory.html">https://kuafu1994.github.io/MoreOnMemory/shared-memory.html</a><br/>
<a href="https://man.openbsd.org/mmap">manpage</a><br/>
<br/>
</p>
<h2 id="leaks">Leaks</h2>
<p>
Unfortunatley we aren't always forget and it is all too easy to forget to ever free a block of memory.<br/>
This isn't too bad when the chunk is small but it's best to try to plug all the leaks you can since it can crash your application or slow it down a lot.<br/>
<br/>
</p>
<h3 id="-fsanitize=address">-fsanitize=address</h3>
<p>
These days any program compiled with AddressSanitizer (ASAN) should automatically any leaks in it even with line numbers.<br/>
<br/>
<pre>
	<code><span style="color:#dfdfbf; font-weight:bold">int</span> <span style="color:#aabfe3">main</span><span style="color:#dcdccc">(</span><span style="color:#dfdfbf; font-weight:bold">void</span><span style="color:#dcdccc">) {</span>
	<span style="color:#dfdfbf; font-weight:bold">char</span><span style="color:#dcdccc">&ast;</span> rand <span style="color:#dcdccc">=</span> <span style="color:#aabfe3">malloc</span><span style="color:#dcdccc">(</span><span style="color:#dca3a3; font-weight:bold">100</span><span style="color:#dcdccc">);</span>
	rand<span style="color:#dcdccc">[</span><span style="color:#dca3a3; font-weight:bold">99</span><span style="color:#dcdccc">] =</span> <span style="color:#cc9393">&apos;\0&apos;</span><span style="color:#dcdccc">;</span>
	<span style="color:#aabfe3">printf</span><span style="color:#dcdccc">(</span><span style="color:#cc9393">&quot;%s</span><span style="color:#dca3a3; font-weight:bold">\n</span><span style="color:#cc9393">&quot;</span><span style="color:#dcdccc">,</span> rand<span style="color:#dcdccc">);</span>
	<span style="color:#7f9f7f; font-style:italic">// No free: free(rand);</span>
<span style="color:#dcdccc">}</span>
	</code>
</pre>
when compiled with asan (& debug info) will give<br/>
<pre>
	<code>&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;
&equals;&equals;16713&equals;&equals;ERROR: LeakSanitizer: detected memory leaks

Direct leak of 100 byte(s) in 1 object(s) allocated from:
    &#35;0 0x29a2cd in malloc (/tmp/e+0x29a2cd)
    &#35;1 0x2c9f21 in main /tmp/e.c:3:15
    &#35;2 0x7fe53f6ead09 in __libc_start_main csu/../csu/libc-start.c:308:16

SUMMARY: AddressSanitizer: 100 byte(s) leaked in 1 allocation(s).
</code>
</pre>
<br/>
</p>
<h3 id="valgrind">Valgrind</h3>
<p>
An external tool called valgrind can also be used to find memory leaks<br/>
<b>NOTE</b>: Asan and valgrind aren't compatible with each other<br/>
It can even report other stuff like using uninitialized values etc.<br/>
<br/>
<pre>
	<code>$ valgrind --memcheck&equals;full ./e
...
&equals;&equals;18045&equals;&equals; 100 bytes in 1 blocks are definitely lost in loss record 1 of 1
&equals;&equals;18045&equals;&equals;    at 0x483877F: malloc (vg_replace_malloc.c:307)
&equals;&equals;18045&equals;&equals;    by 0x201171: main (e.c:3)
...
</code>
</pre>
			<footer style="margin-bottom: 2em;">
				<a class="special" href="/out/index.html">Return To Index</a>
			</footer>
	  </article>
	</body>
</html>
